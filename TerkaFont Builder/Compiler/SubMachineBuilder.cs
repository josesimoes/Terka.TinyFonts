namespace Terka.FontBuilder.Compiler
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Terka.FontBuilder.Compiler.Output;
    using Terka.FontBuilder.Parser.Output.Substitution;

    /// <summary>
    /// State machine builder used to construct sub-machines for context transformations.
    /// </summary>
    public class SubMachineBuilder : IStateMachineBuilder
    {
        public const ushort ContextTerminatorGlyphId = ushort.MaxValue;

        /// <summary>
        /// So-far added paths.
        /// </summary>
        private readonly List<List<ITransition>> paths = new List<List<ITransition>>();

        /// <summary>
        /// The lookup flags of the sub-machine
        /// </summary>
        private readonly LookupFlags subMachineLookupFlags;

        /// <summary>
        /// Initializes a new instance of the <see cref="SubMachineBuilder" /> class.
        /// </summary>
        /// <param name="subMachineLookupFlags">The sub machine lookup flags.</param>
        public SubMachineBuilder(LookupFlags subMachineLookupFlags)
        {
            this.subMachineLookupFlags = subMachineLookupFlags;
        }

        /// <inheritdoc />
        public void AddPath(IEnumerable<ITransition> path)
        {
            this.paths.Add(path.ToList());
        }

        /// <summary>
        /// Sub-machines are not allowed to be processed in reverse (this is slight difference from OT spec - there context transformations
        /// can theoretically contain <see cref="ReverseChainingContextSubstitutionTable"/>s).
        /// </summary>
        /// <param name="direction">The direction.</param>
        void IStateMachineBuilder.SetProcessingDirection(ProcessingDirection direction)
        {
            if (direction == ProcessingDirection.EndToStart)
            {
                throw new NotImplementedException();   
            }            
        }

        /// <summary>
        /// Returns paths generated by the sub-machine.
        /// </summary>
        /// <returns>Collection of paths.</returns>
        public IEnumerable<IEnumerable<ITransition>> GetPaths()
        {
            foreach (var path in this.paths)
            {
                var morphedPath = this.LinkPathToSubmachineEntryState(path);
                yield return morphedPath;
            }

            // Add a path which ends the sub-machine and removes the terminator.
            yield return new[]
            {
                this.CreateSubMachineEntryStep(),
                new SimpleTransition 
                {
                    GlyphId = ContextTerminatorGlyphId,
                    HeadShift = 0,
                    Action = new SubstitutionAction
                    {
                        ReplacedGlyphCount = 1,
                        ReplacementGlyphIds = Enumerable.Empty<ushort>()
                    }
                }
            };
        }

        private IEnumerable<ITransition> LinkPathToSubmachineEntryState(IEnumerable<ITransition> path)
        {
            var pathList = path.ToList();
            
            /* Even though paths usually don't include first step, this one has to (because it will be 
             * appended to the part of the path which precedes the sub-machine). It also makes the sub-
             * machine path self-enclosed (the fallback edges don't go out of the path). */
            var subMachineEntryStep = this.CreateSubMachineEntryStep();
            if (pathList.Any() && (pathList[0].TargetState == null || pathList[0].TargetState.Transitions.All(p => !p.IsFallback)))
            {
                subMachineEntryStep.TargetState.Transitions = new ITransition[]
                {
                    new AlwaysTransition
                    {
                        TargetState = subMachineEntryStep.TargetState,
                        HeadShift = 1
                    }
                };
            }

            yield return subMachineEntryStep;

            for (int i = 0; i < pathList.Count; i++)
            {
                var stepClone = pathList[i].Clone();
                stepClone.TargetState = new State();

                /* When the sub-machine fails to recognize a glyph, it must fall back to its entry state,
                    * not the outer machine's entry state. To do this, an explicit fallback transition to the 
                    * local entry state has to be created. */
                if (i < pathList.Count - 1 && !(pathList[i].IsFallback))
                {
                    /* Do not add the fallback to the local sub-machine entry state if the state already has 
                        * another fallback transition. This usually means that the sub-machine has another "sub-sub"-
                        * machine within or contains ligature recognition chain. */
                    yield return stepClone;
                }
                else
                {
                    stepClone.TargetState.Transitions.Add(
                        new AlwaysTransition
                        {
                            TargetState = subMachineEntryStep.TargetState
                        });
                    yield return stepClone;
                }
            }
        }

        private ITransition CreateSubMachineEntryStep()
        {
            return new AlwaysTransition
            {
                HeadShift = 0, 
                //LookupFlags = this.subMachineLookupFlags,
                TargetState = new State()
            };
        }
    }
}
